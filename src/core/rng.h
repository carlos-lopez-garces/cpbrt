#ifndef CPBRT_CORE_RNG_H
#define CPBRT_CORE_RNG_H

#include <algorithm>

#include "cpbrt.h"

// Largest representable floating-point number that is less than 1.
#ifdef CPBRT_FLOAT_AS_DOUBLE
static const Float OneMinusEpsilon = 0x1.fffffffffffffp-1;
#else
static const Float OneMinusEpsilon = 0x1.fffffep-1;
#endif

#define PCG32_DEFAULT_STATE 0x853c49e6748fea9bULL
#define PCG32_DEFAULT_STREAM 0xda3e39cb94b95bdbULL
#define PCG32_MULT 0x5851f42d4c957f2dULL

// Permuted Congruential Generator (PCG) pseudo-random number generator. The sequences
// generated by this RNG do not overlap.
class RNG {
private:
    uint64_t state;
    uint64_t inc;

public:
    // Default initialization.
    RNG();

    // sequenceIndex selects a sequence of pseudo-random values.
    RNG(uint64_t sequenceIndex) {
        SetSequence(sequenceIndex);
    }

    // Selects the sequence to use.
    void SetSequence(uint64_t sequenceIndex);

    uint32_t UniformUInt32();

    uint32_t UniformUInt32(uint32_t b) {
        // 2^32 % b, computed efficiently using 32-bit arithmetic.
        uint32_t threshold = (~b + 1u) % b;

        // Just UniformUInt32() % b gives a higher probability of choosing values in
        // [0, 2^32 % b]. What we want is to choose uniformly across [0, b].
        while (true) {
            uint32_t r = UniformUInt32();
            if (r >= threshold) {
                return r % b;
            }
        }
    }

    Float UniformFloat() {
#ifndef CPBRT_HAVE_HEX_FP_CONSTANTS
        return std::min(OneMinusEpsilon, Float(UniformUInt32() * 2.3283064365386963e-10f));
#else
        return std::min(OneMinusEpsilon, Float(UniformUInt32() * 0x1p-32f));
#endif
    }
};

inline RNG::RNG() : state(PCG32_DEFAULT_STATE), inc(PCG32_DEFAULT_STREAM) {}

inline void RNG::SetSequence(uint64_t sequenceIndex) {
    state = 0u;
    inc = (sequenceIndex << 1u) | 1u;
    UniformUInt32();
    state += PCG32_DEFAULT_STATE;
    UniformUInt32();
    // The state, as left by UniformUInt32(), determines the sequence uniquely and in its
    // entirety: Permuted Congruential Generators generate sequences that don't overlap, so
    // they are determined uniquely by any of their values.
}

inline uint32_t RNG::UniformUInt32() {
    uint64_t oldState = state;
    // This would be the output of a Linear Congruential Generator, pre modulo, which is
    // defined as the recurrence relation: X_n+1 = (aX_n + c) mod m.
    state = oldState * PCG32_MULT + inc;

    // A Permuted Congruential Generator applies transformations to the output of the LCG.
    uint32_t xorshifted = (uint32_t) (((oldState >> 18u) ^ oldState) >> 27u);
    uint32_t rot = (uint32_t) (oldState >> 59u);

    return (xorshifted >> rot) | (xorshifted << ((~rot + 1u) & 31));
}

#endif // CPBRT_CORE_RNG_H