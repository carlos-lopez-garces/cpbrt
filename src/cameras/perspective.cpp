#include "perspective.h"

PerspectiveCamera::PerspectiveCamera(
    const Transform &CameraToWorld,
    const Bounds2f &screenWindow,
    Float shutterOpen,
    Float shutterClose,
    Float lensRadius,
    Float focalDistance,
    Float fov,
    Film *film,
    const Medium *medium
) : ProjectiveCamera(
    CameraToWorld,
    Perspective(fov, 1e-2f, 1000.f),
    screenWindow,
    shutterOpen,
    shutterClose,
    lensRadius,
    focalDistance,
    film,
    medium
) {
    // Compute differential changes in origin for perspective camera rays.
    dxCamera = RasterToCamera(Point3f(1, 0, 0)) - RasterToCamera(Point3f(0, 0, 0));
    dyCamera = RasterToCamera(Point3f(0, 1, 0)) - RasterToCamera(Point3f(0, 0, 0));

    // TODO: Compute image plane bounds at z=1 for PerspectiveCamera.
}

Float PerspectiveCamera::GenerateRay(const CameraSample &sample, Ray *ray) const {
    // Compute the ray's origin by transforming the raster space sample's position
    // on the film to camera space.
    Point3f pFilm = Point3f(sample.pFilm.x, sample.pFilm.y, 0);
    Point3f pCamera = RasterToCamera(pFilm);

    // Rays generated by a perspective camera have their origin at the origin of 
    // camera space.
    *ray = Ray(Point3f(0, 0, 0), Normalize(Vector3f(pCamera)));

    // TODO: Modify ray for depth of field.

    ray->time = Lerp(sample.time, shutterOpen, shutterClose);
    ray->medium = medium;

    // Transform the ray to world space before returning it.
    *ray = CameraToWorld(*ray);

    // ?
    return 1;
}

Float PerspectiveCamera::GenerateRayDifferential(
    const CameraSample &sample,
    RayDifferential *rd
) const {
    // Compute the main ray's origin by transforming the raster space sample's position
    // on the film to camera space.
    Point3f pFilm = Point3f(sample.pFilm.x, sample.pFilm.y, 0);
    Point3f pCamera = RasterToCamera(pFilm);

    // Rays generated by a perspective camera have their origin at the origin of 
    // camera space.
    *rd = RayDifferential(Point3f(0, 0, 0), Normalize(Vector3f(pCamera)));

    // TODO: Modify ray for depth of field.

    if (lensRadius > 0) {
        // TODO: Compute PerspectiveCamera ray differentials accounting for lens.
    } else {
        rd->rxOrigin = rd->o;
        rd->ryOrigin = rd->o;
        rd->rxDirection = Normalize(Vector3f(pCamera) + dxCamera);
        rd->ryDirection = Normalize(Vector3f(pCamera) + dyCamera);
    }

    rd->time = Lerp(sample.time, shutterOpen, shutterClose);
    rd->hasDifferentials = true;
    rd->medium = medium;

    // Transform the ray to world space before returning it.
    *rd = CameraToWorld(*rd);

    // ?
    return 1;
}